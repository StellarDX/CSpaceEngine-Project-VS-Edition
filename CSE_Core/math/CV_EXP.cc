#include "../headers/math/CSEM_Func.h"
#include "../headers/math/CSEM_Algo.h"

// Exponential function implemented by OpenCV

// OpenCV Doc: https://docs.opencv.org/4.x/d3/ddd/group__core__hal__functions.html#gaaa6369f0c58d52fb7faca9d2b697479f
// Reference: https://www.cnblogs.com/zlom/p/15416326.html

_CSE_BEGIN

#define EXPPOLY_A0 0.00961812910762847716197907157366L // (ln2)^4 / 4!

// OpenCV converted exp(x) to 2^x.
// The taylor series of exponential function 2^x is SUM<0, +inf>((pow(x, n) * pow(ln(2), n)) / n!)
// Take the first 4 terms, it can be simplified as ((((x0 + A1)*x0 + A2)*x0 + A3)*x0 + A4)
// In this case, A0 = (ln2)^4 / 4!, A1 = (ln2)^3 / (3! * A0), A2 = (ln2)^2 / (2! * A0)
// A3 = ln2 / A0, A4 = 1 / A0
// However, each coefficient has divided an extra A0 when replacing A0-4 into the original equation.
// So we need a table of value to eliminate them.

// This table stores the 64th-root of pow(2, 0 - 63) * A0
static const float96 _Exponential_Tab[]
(
	1.0000000000000000000000000000000L * EXPPOLY_A0,
	1.0108892860517004600204097905619L * EXPPOLY_A0,
	1.0218971486541166782344801347833L * EXPPOLY_A0,
	1.0330248790212284225001082839705L * EXPPOLY_A0,
	1.0442737824274138403219664787399L * EXPPOLY_A0,
	1.0556451783605571588083413251529L * EXPPOLY_A0,
	1.0671404006768236181695211209928L * EXPPOLY_A0,
	1.0787607977571197937406800374385L * EXPPOLY_A0,
	1.0905077326652576592070106557607L * EXPPOLY_A0,
	1.1023825833078409435564142094256L * EXPPOLY_A0,
	1.1143867425958925363088129569196L * EXPPOLY_A0,
	1.1265216186082418997947986437870L * EXPPOLY_A0,
	1.1387886347566916537038302838415L * EXPPOLY_A0,
	1.1511892299529827058177596352020L * EXPPOLY_A0,
	1.1637248587775775138135735990922L * EXPPOLY_A0,
	1.1763969916502812762846457284838L * EXPPOLY_A0,
	1.1892071150027210667174999705605L * EXPPOLY_A0,
	1.2021567314527031420963969574978L * EXPPOLY_A0,
	1.2152473599804688781165202513388L * EXPPOLY_A0,
	1.2284805361068700056940089577928L * EXPPOLY_A0,
	1.2418578120734840485936774687266L * EXPPOLY_A0,
	1.2553807570246910895793906574423L * EXPPOLY_A0,
	1.2690509571917332225544190810323L * EXPPOLY_A0,
	1.2828700160787782807266697810215L * EXPPOLY_A0,
	1.2968395546510096659337541177925L * EXPPOLY_A0,
	1.3109612115247643419229917863308L * EXPPOLY_A0,
	1.3252366431597412946295370954987L * EXPPOLY_A0,
	1.3396675240533030053600306697244L * EXPPOLY_A0,
	1.3542555469368927282980147401407L * EXPPOLY_A0,
	1.3690024229745906119296011329822L * EXPPOLY_A0,
	1.3839098819638319548726595272652L * EXPPOLY_A0,
	1.3989796725383111402095281367152L * EXPPOLY_A0,
	1.4142135623730950488016887242097L * EXPPOLY_A0,
	1.4296133383919700112350657782751L * EXPPOLY_A0,
	1.4451808069770466200370062414717L * EXPPOLY_A0,
	1.4609177941806469886513028903106L * EXPPOLY_A0,
	1.4768261459394993113869074803740L * EXPPOLY_A0,
	1.4929077282912648492006435314867L * EXPPOLY_A0,
	1.5091644275934227397660195510332L * EXPPOLY_A0,
	1.5255981507445383068512536895169L * EXPPOLY_A0,
	1.5422108254079408236122918620907L * EXPPOLY_A0,
	1.5590044002378369670337280894749L * EXPPOLY_A0,
	1.5759808451078864864552701601819L * EXPPOLY_A0,
	1.5931421513422668979372486431191L * EXPPOLY_A0,
	1.6104903319492543081795206673574L * EXPPOLY_A0,
	1.6280274218573477668482185220140L * EXPPOLY_A0,
	1.6457554781539648445187567247258L * EXPPOLY_A0,
	1.6636765803267364350463364569764L * EXPPOLY_A0,
	1.6817928305074290860622509524664L * EXPPOLY_A0,
	1.7001063537185234695013625734975L * EXPPOLY_A0,
	1.7186192981224779156293443764563L * EXPPOLY_A0,
	1.7373338352737062489942020818722L * EXPPOLY_A0,
	1.7562521603732994831121606193753L * EXPPOLY_A0,
	1.7753764925265212525505592001993L * EXPPOLY_A0,
	1.7947090750031071864277032421278L * EXPPOLY_A0,
	1.8142521755003987562498346003623L * EXPPOLY_A0,
	1.8340080864093424634870831895883L * EXPPOLY_A0,
	1.8539791250833855683924530703377L * EXPPOLY_A0,
	1.8741676341102999013299989499544L * EXPPOLY_A0,
	1.8945759815869656413402186534269L * EXPPOLY_A0,
	1.9152065613971472938726112702958L * EXPPOLY_A0,
	1.9360617934922944505980559045667L * EXPPOLY_A0,
	1.9571441241754002690183222516269L * EXPPOLY_A0,
	1.9784560263879509682582499181312L * EXPPOLY_A0
);

_Check_return_ float64 __cdecl exp(_In_ float64 _X, EXP_CONFIG _Conf)
{
	#if !defined(_USE_CV_FUNCTIONS) && ((defined _MSC_VER && _MSC_VER >= 1900) || defined(__EMSCRIPTEN__))
	return std::exp(_X);
	#else

	// e^x = 2^(log2(e^x)) = 2^(x*log2(e))
	static const float96 EXP_PRESCALE = CSE_LOG2E * (1 << _Conf.SCALE);
	static const float96 EXP_POSTSCALE = 1.l / (1 << _Conf.SCALE);
	static const float96 EXP_MAX = 3000.l * (1 << _Conf.SCALE);

	// EXP64F
	// Coefficients of talor series
	// A5 + A4 * x + A3 * x^2 + A2 * x^3 + A1 * x^4 + A0 * x^5
	// Expand to 6-terms to increase precision for 64-bit real number.
	const float96 A5 = 1.00000000000000000000000000000000L / EXPPOLY_A0; // ln2^0 / 0!
	const float96 A4 = 0.69314718055994530941723212145818L / EXPPOLY_A0; // ln2^1 / 1!
	const float96 A3 = 0.24022650695910071233355126316333L / EXPPOLY_A0; // ln2^2 / 2!
	const float96 A2 = 0.05550410866482157995314226376862L / EXPPOLY_A0; // ln2^3 / 3!
	const float96 A1 = 0.00961812910762847716197907157366L / EXPPOLY_A0; // ln2^3 / 3!
	const float96 A0 = 0.00133335581464284434234122219880L / EXPPOLY_A0; // ln2^3 / 3!

	float96 MIN = -EXP_MAX / EXP_PRESCALE;
	float96 MAX = +EXP_MAX / EXP_PRESCALE;

	// Create buffer
	float64 x0 = clamp(_X, MIN, MAX);
	x0 *= EXP_PRESCALE;
	int64 Buffer;

	// Separate integer and fractional part
	int64 xi = clamp((int64)x0, INT_MIN, INT_MAX);
	x0 = (x0 - xi) * EXP_POSTSCALE;

	int64 Offset = (1 << (_Conf.BITSEXPO - 1)) - 1; // Calculate offset
	int64 MaxExpo = (Offset + 1) * 2 - 1;

	// move integer part to exponential bits
	int64 Expo = (xi >> _Conf.SCALE) + Offset;
	Expo = !(Expo & ~MaxExpo) ? Expo : Expo < 0 ? 0 : MaxExpo;
	Buffer = Expo << _Conf.BITSFRAC;

	return wrtval<int64, float64>(Buffer) * _Conf.TABLE[xi & _Conf.MASK] *
		(((((A0 * x0 + A1) * x0 + A2) * x0 + A3) * x0 + A4) * x0 + A5);

	#endif
}

_Check_return_ complex64 __cdecl exp(_In_ complex64 _X, EXP_CONFIG _Conf)
{
	return _CSE exp(_X.real(), _Conf) * (std::cos(_X.imag()) + 1i * std::sin(_X.imag()));
}

_CSE_END